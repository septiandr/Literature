{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\")); // TODO: Implement using only matrices to support skew and even more operations than css.\n\n\nvar applySingleTransformation = function applySingleTransformation(ctx, transform, origin) {\n  var operation = transform.operation,\n      value = transform.value;\n\n  switch (operation) {\n    case 'scale':\n      {\n        var scaleX = value[0],\n            scaleY = value[1];\n        ctx.scale(scaleX, scaleY, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'rotate':\n      {\n        var angle = value[0];\n        ctx.rotate(angle, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'translate':\n      {\n        var x = value[0],\n            y = value[1];\n        ctx.translate(x, y, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'matrix':\n      {\n        ctx.transform.apply(ctx, value);\n        break;\n      }\n\n    default:\n      {\n        console.error(\"Transform operation: '\" + operation + \"' doesn't supported\");\n      }\n  }\n};\n\nvar applyTransformations = function applyTransformations(ctx, node) {\n  var _node$style, _node$props;\n\n  if (!node.origin) return node;\n  var origin = [node.origin.left, node.origin.top];\n  var operations = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.transform) || ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.transform) || [];\n  operations.forEach(function (operation) {\n    applySingleTransformation(ctx, operation, origin);\n  });\n  return node;\n};\n\nvar _default = R.curryN(2, applyTransformations);\n\nexports.default = _default;","map":{"version":3,"sources":["D:/pelatihan/batch 27/Literature/client/node_modules/@react-pdf/render/lib/operations/transform.js"],"names":["_interopRequireWildcard","require","exports","__esModule","default","R","applySingleTransformation","ctx","transform","origin","operation","value","scaleX","scaleY","scale","angle","rotate","x","y","translate","apply","console","error","applyTransformations","node","_node$style","_node$props","left","top","operations","style","props","forEach","_default","curryN"],"mappings":"AAAA;;AAEA,IAAIA,uBAAuB,GAAGC,OAAO,CAAC,+CAAD,CAArC;;AAEAC,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,CAAC,GAAGL,uBAAuB,CAACC,OAAO,CAAC,OAAD,CAAR,CAA/B,C,CAEA;;;AACA,IAAIK,yBAAyB,GAAG,SAASA,yBAAT,CAAmCC,GAAnC,EAAwCC,SAAxC,EAAmDC,MAAnD,EAA2D;AACzF,MAAIC,SAAS,GAAGF,SAAS,CAACE,SAA1B;AAAA,MACIC,KAAK,GAAGH,SAAS,CAACG,KADtB;;AAGA,UAAQD,SAAR;AACE,SAAK,OAAL;AACE;AACE,YAAIE,MAAM,GAAGD,KAAK,CAAC,CAAD,CAAlB;AAAA,YACIE,MAAM,GAAGF,KAAK,CAAC,CAAD,CADlB;AAEAJ,QAAAA,GAAG,CAACO,KAAJ,CAAUF,MAAV,EAAkBC,MAAlB,EAA0B;AACxBJ,UAAAA,MAAM,EAAEA;AADgB,SAA1B;AAGA;AACD;;AAEH,SAAK,QAAL;AACE;AACE,YAAIM,KAAK,GAAGJ,KAAK,CAAC,CAAD,CAAjB;AACAJ,QAAAA,GAAG,CAACS,MAAJ,CAAWD,KAAX,EAAkB;AAChBN,UAAAA,MAAM,EAAEA;AADQ,SAAlB;AAGA;AACD;;AAEH,SAAK,WAAL;AACE;AACE,YAAIQ,CAAC,GAAGN,KAAK,CAAC,CAAD,CAAb;AAAA,YACIO,CAAC,GAAGP,KAAK,CAAC,CAAD,CADb;AAEAJ,QAAAA,GAAG,CAACY,SAAJ,CAAcF,CAAd,EAAiBC,CAAjB,EAAoB;AAClBT,UAAAA,MAAM,EAAEA;AADU,SAApB;AAGA;AACD;;AAEH,SAAK,QAAL;AACE;AACEF,QAAAA,GAAG,CAACC,SAAJ,CAAcY,KAAd,CAAoBb,GAApB,EAAyBI,KAAzB;AACA;AACD;;AAEH;AACE;AACEU,QAAAA,OAAO,CAACC,KAAR,CAAc,2BAA2BZ,SAA3B,GAAuC,qBAArD;AACD;AAvCL;AAyCD,CA7CD;;AA+CA,IAAIa,oBAAoB,GAAG,SAASA,oBAAT,CAA8BhB,GAA9B,EAAmCiB,IAAnC,EAAyC;AAClE,MAAIC,WAAJ,EAAiBC,WAAjB;;AAEA,MAAI,CAACF,IAAI,CAACf,MAAV,EAAkB,OAAOe,IAAP;AAClB,MAAIf,MAAM,GAAG,CAACe,IAAI,CAACf,MAAL,CAAYkB,IAAb,EAAmBH,IAAI,CAACf,MAAL,CAAYmB,GAA/B,CAAb;AACA,MAAIC,UAAU,GAAG,CAAC,CAACJ,WAAW,GAAGD,IAAI,CAACM,KAApB,MAA+B,IAA/B,IAAuCL,WAAW,KAAK,KAAK,CAA5D,GAAgE,KAAK,CAArE,GAAyEA,WAAW,CAACjB,SAAtF,MAAqG,CAACkB,WAAW,GAAGF,IAAI,CAACO,KAApB,MAA+B,IAA/B,IAAuCL,WAAW,KAAK,KAAK,CAA5D,GAAgE,KAAK,CAArE,GAAyEA,WAAW,CAAClB,SAA1L,KAAwM,EAAzN;AACAqB,EAAAA,UAAU,CAACG,OAAX,CAAmB,UAAUtB,SAAV,EAAqB;AACtCJ,IAAAA,yBAAyB,CAACC,GAAD,EAAMG,SAAN,EAAiBD,MAAjB,CAAzB;AACD,GAFD;AAGA,SAAOe,IAAP;AACD,CAVD;;AAYA,IAAIS,QAAQ,GAAG5B,CAAC,CAAC6B,MAAF,CAAS,CAAT,EAAYX,oBAAZ,CAAf;;AAEArB,OAAO,CAACE,OAAR,GAAkB6B,QAAlB","sourcesContent":["\"use strict\";\n\nvar _interopRequireWildcard = require(\"@babel/runtime/helpers/interopRequireWildcard\");\n\nexports.__esModule = true;\nexports.default = void 0;\n\nvar R = _interopRequireWildcard(require(\"ramda\"));\n\n// TODO: Implement using only matrices to support skew and even more operations than css.\nvar applySingleTransformation = function applySingleTransformation(ctx, transform, origin) {\n  var operation = transform.operation,\n      value = transform.value;\n\n  switch (operation) {\n    case 'scale':\n      {\n        var scaleX = value[0],\n            scaleY = value[1];\n        ctx.scale(scaleX, scaleY, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'rotate':\n      {\n        var angle = value[0];\n        ctx.rotate(angle, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'translate':\n      {\n        var x = value[0],\n            y = value[1];\n        ctx.translate(x, y, {\n          origin: origin\n        });\n        break;\n      }\n\n    case 'matrix':\n      {\n        ctx.transform.apply(ctx, value);\n        break;\n      }\n\n    default:\n      {\n        console.error(\"Transform operation: '\" + operation + \"' doesn't supported\");\n      }\n  }\n};\n\nvar applyTransformations = function applyTransformations(ctx, node) {\n  var _node$style, _node$props;\n\n  if (!node.origin) return node;\n  var origin = [node.origin.left, node.origin.top];\n  var operations = ((_node$style = node.style) === null || _node$style === void 0 ? void 0 : _node$style.transform) || ((_node$props = node.props) === null || _node$props === void 0 ? void 0 : _node$props.transform) || [];\n  operations.forEach(function (operation) {\n    applySingleTransformation(ctx, operation, origin);\n  });\n  return node;\n};\n\nvar _default = R.curryN(2, applyTransformations);\n\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}