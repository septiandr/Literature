{"ast":null,"code":"'use strict';\n\nfunction _interopDefault(ex) {\n  return ex && typeof ex === 'object' && 'default' in ex ? ex['default'] : ex;\n}\n\nvar _slicedToArray = _interopDefault(require('babel-runtime/helpers/slicedToArray'));\n\nvar _getIterator = _interopDefault(require('babel-runtime/core-js/get-iterator'));\n\nvar _defineProperty = _interopDefault(require('babel-runtime/helpers/defineProperty'));\n\nvar _regeneratorRuntime = _interopDefault(require('babel-runtime/regenerator'));\n\nvar _Symbol$iterator = _interopDefault(require('babel-runtime/core-js/symbol/iterator'));\n\nvar _classCallCheck = _interopDefault(require('babel-runtime/helpers/classCallCheck'));\n\nvar _createClass = _interopDefault(require('babel-runtime/helpers/createClass'));\n\nvar INITIAL_STATE = 1;\nvar FAIL_STATE = 0;\n/**\n * A StateMachine represents a deterministic finite automaton.\n * It can perform matches over a sequence of values, similar to a regular expression.\n */\n\nvar StateMachine = function () {\n  function StateMachine(dfa) {\n    _classCallCheck(this, StateMachine);\n\n    this.stateTable = dfa.stateTable;\n    this.accepting = dfa.accepting;\n    this.tags = dfa.tags;\n  }\n  /**\n   * Returns an iterable object that yields pattern matches over the input sequence.\n   * Matches are of the form [startIndex, endIndex, tags].\n   */\n\n\n  _createClass(StateMachine, [{\n    key: 'match',\n    value: function match(str) {\n      var self = this;\n      return _defineProperty({}, _Symbol$iterator, _regeneratorRuntime.mark(function _callee() {\n        var state, startRun, lastAccepting, lastState, p, c;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                state = INITIAL_STATE;\n                startRun = null;\n                lastAccepting = null;\n                lastState = null;\n                p = 0;\n\n              case 5:\n                if (!(p < str.length)) {\n                  _context.next = 21;\n                  break;\n                }\n\n                c = str[p];\n                lastState = state;\n                state = self.stateTable[state][c];\n\n                if (!(state === FAIL_STATE)) {\n                  _context.next = 15;\n                  break;\n                }\n\n                if (!(startRun != null && lastAccepting != null && lastAccepting >= startRun)) {\n                  _context.next = 13;\n                  break;\n                }\n\n                _context.next = 13;\n                return [startRun, lastAccepting, self.tags[lastState]];\n\n              case 13:\n                // reset the state as if we started over from the initial state\n                state = self.stateTable[INITIAL_STATE][c];\n                startRun = null;\n\n              case 15:\n                // start a run if not in the failure state\n                if (state !== FAIL_STATE && startRun == null) {\n                  startRun = p;\n                } // if accepting, mark the potential match end\n\n\n                if (self.accepting[state]) {\n                  lastAccepting = p;\n                } // reset the state to the initial state if we get into the failure state\n\n\n                if (state === FAIL_STATE) {\n                  state = INITIAL_STATE;\n                }\n\n              case 18:\n                p++;\n                _context.next = 5;\n                break;\n\n              case 21:\n                if (!(startRun != null && lastAccepting != null && lastAccepting >= startRun)) {\n                  _context.next = 24;\n                  break;\n                }\n\n                _context.next = 24;\n                return [startRun, lastAccepting, self.tags[state]];\n\n              case 24:\n              case 'end':\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * For each match over the input sequence, action functions matching\n     * the tag definitions in the input pattern are called with the startIndex,\n     * endIndex, and sub-match sequence.\n     */\n\n  }, {\n    key: 'apply',\n    value: function apply(str, actions) {\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = _getIterator(this.match(str)), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var _step$value = _slicedToArray(_step.value, 3);\n\n          var start = _step$value[0];\n          var end = _step$value[1];\n          var tags = _step$value[2];\n          var _iteratorNormalCompletion2 = true;\n          var _didIteratorError2 = false;\n          var _iteratorError2 = undefined;\n\n          try {\n            for (var _iterator2 = _getIterator(tags), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n              var tag = _step2.value;\n\n              if (typeof actions[tag] === 'function') {\n                actions[tag](start, end, str.slice(start, end + 1));\n              }\n            }\n          } catch (err) {\n            _didIteratorError2 = true;\n            _iteratorError2 = err;\n          } finally {\n            try {\n              if (!_iteratorNormalCompletion2 && _iterator2.return) {\n                _iterator2.return();\n              }\n            } finally {\n              if (_didIteratorError2) {\n                throw _iteratorError2;\n              }\n            }\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n    }\n  }]);\n\n  return StateMachine;\n}();\n\nmodule.exports = StateMachine;","map":{"version":3,"sources":["src/StateMachine.js"],"names":["INITIAL_STATE","FAIL_STATE","StateMachine","dfa","str","self","p","state","startRun","lastAccepting","actions","start","end","tags","tag"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,IAAMA,aAAAA,GAAN,CAAA;AACA,IAAMC,UAAAA,GAAN,CAAA;;;;;;IAMqBC,YAAAA,GAAAA,YAAAA;wBACnB,G,EAAiB;;;SACf,U,GAAkBC,GAAAA,CAAlB,U;SACA,S,GAAiBA,GAAAA,CAAjB,S;SACA,I,GAAYA,GAAAA,CAAZ,I;;;;;;;;;;0BAOIC,G,EAAK;UACLC,IAAAA,GAAJ,I;;;;;;;qBACA,GAAA,a;wBAAA,GAAA,I;6BAAA,GAAA,I;yBAAA,GAAA,I;iBAAA,GAAA,C;;;sBAOoBC,CAAAA,GAAIF,GAAAA,CAPxB,M,GAAA;;;;;iBAAA,GAQcA,GAAAA,CARd,CAQcA,C;4BAER,K;wBACQC,IAAAA,CAAAA,UAAAA,CAAAA,KAAAA,EAAR,CAAQA,C;;sBAEJE,KAAAA,KAbV,U,GAAA;;;;;sBAeYC,QAAAA,IAAAA,IAAAA,IAAoBC,aAAAA,IAApBD,IAAAA,IAA6CC,aAAAA,IAfzD,Q,GAAA;;;;;;uBAgBgB,CAAA,QAAA,EAAA,aAAA,EAA0BJ,IAAAA,CAAAA,IAAAA,CAhB1C,SAgB0CA,CAA1B,C;;;;wBAIAA,IAAAA,CAAAA,UAAAA,CAAAA,aAAAA,EAAR,CAAQA,C;2BACR,I;;;;oBAIEE,KAAAA,KAAAA,UAAAA,IAAwBC,QAAAA,IAA5B,I,EAA8C;6BAC5C,C;;;;oBAIEH,IAAAA,CAAAA,SAAAA,CAAJ,KAAIA,C,EAAuB;kCACzB,C;;;;oBAIEE,KAAAA,KAAJ,U,EAA0B;0BACxB,a;;;;iBApCR;;;;;sBAyCQC,QAAAA,IAAAA,IAAAA,IAAoBC,aAAAA,IAApBD,IAAAA,IAA6CC,aAAAA,IAzCrD,Q,GAAA;;;;;;uBA0CY,CAAA,QAAA,EAAA,aAAA,EAA0BJ,IAAAA,CAAAA,IAAAA,CA1CtC,KA0CsCA,CAA1B,C;;;;;;;;;;;;;;;;;;0BAWRD,G,EAAKM,O,EAAS;;;;;;0CACa,KAAA,KAAA,CAA/B,GAA+B,C,GAA/B,K,EAAA,EAAA,yBAAA,GAAA,CAAA,KAAA,GAAA,SAAA,CAAA,IAAA,EAAA,EAAA,IAAA,C,EAAA,yBAAA,GAAA,I,EAAgD;;;cAAtCC,KAAsC,GAAA,WAAA,CAAA,CAAA,C;cAA/BC,GAA+B,GAAA,WAAA,CAAA,CAAA,C;cAA1BC,IAA0B,GAAA,WAAA,CAAA,CAAA,C;;;;;;+CAC9C,I,GAAA,M,EAAA,EAAA,0BAAA,GAAA,CAAA,MAAA,GAAA,UAAA,CAAA,IAAA,EAAA,EAAA,IAAA,C,EAAA,0BAAA,GAAA,I,EAAsB;kBAAbC,GAAa,GAAA,MAAA,CAAA,K;;kBAChB,OAAOJ,OAAAA,CAAP,GAAOA,CAAP,KAAJ,U,EAAwC;wBACtC,G,EAAA,K,EAAA,G,EAAyBN,GAAAA,CAAAA,KAAAA,CAAAA,KAAAA,EAAiBQ,GAAAA,GAA1C,CAAyBR,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAtEdF,E","sourcesContent":["const INITIAL_STATE = 1;\nconst FAIL_STATE = 0;\n\n/**\n * A StateMachine represents a deterministic finite automaton.\n * It can perform matches over a sequence of values, similar to a regular expression.\n */\nexport default class StateMachine {\n  constructor(dfa) {\n    this.stateTable = dfa.stateTable;\n    this.accepting = dfa.accepting;\n    this.tags = dfa.tags;\n  }\n\n  /**\n   * Returns an iterable object that yields pattern matches over the input sequence.\n   * Matches are of the form [startIndex, endIndex, tags].\n   */\n  match(str) {\n    let self = this;\n    return {\n      *[Symbol.iterator]() {\n        let state = INITIAL_STATE;\n        let startRun = null;\n        let lastAccepting = null;\n        let lastState = null;\n\n        for (let p = 0; p < str.length; p++) {\n          let c = str[p];\n\n          lastState = state;\n          state = self.stateTable[state][c];\n\n          if (state === FAIL_STATE) {\n            // yield the last match if any\n            if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {\n              yield [startRun, lastAccepting, self.tags[lastState]];\n            }\n\n            // reset the state as if we started over from the initial state\n            state = self.stateTable[INITIAL_STATE][c];\n            startRun = null;\n          }\n\n          // start a run if not in the failure state\n          if (state !== FAIL_STATE && startRun == null) {\n            startRun = p;\n          }\n\n          // if accepting, mark the potential match end\n          if (self.accepting[state]) {\n            lastAccepting = p;\n          }\n\n          // reset the state to the initial state if we get into the failure state\n          if (state === FAIL_STATE) {\n            state = INITIAL_STATE;\n          }\n        }\n\n        // yield the last match if any\n        if (startRun != null && lastAccepting != null && lastAccepting >= startRun) {\n          yield [startRun, lastAccepting, self.tags[state]];\n        }\n      }\n    };\n  }\n\n  /**\n   * For each match over the input sequence, action functions matching\n   * the tag definitions in the input pattern are called with the startIndex,\n   * endIndex, and sub-match sequence.\n   */\n  apply(str, actions) {\n    for (let [start, end, tags] of this.match(str)) {\n      for (let tag of tags) {\n        if (typeof actions[tag] === 'function') {\n          actions[tag](start, end, str.slice(start, end + 1));\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"script"}